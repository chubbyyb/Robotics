/*
This code follows a line by generating a threshold of color of the ground and the line,
It will follow the line by turning left when its on the line, 
And turn right when its not on it to get back on it.

If it detects an obstacle, it will call a function that goes around it and back onto the line.
*/

#pragma config(Sensor, S1,     colorSensor,    sensorEV3_Color)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


// Drive function to turn the robot left
void driveLeft1(long power)
{
	setMotorSpeed(rightMotor, power);
	setMotorSpeed(leftMotor, power / 2);
}

// Drive function to turn the robot right
void driveRight1(long power)
{
	setMotorSpeed(rightMotor, power / 2);
	setMotorSpeed(leftMotor, power);
}

// Drive function to move the robot forward
void drive(long power)
{
	setMotorSpeed(rightMotor, power);
	setMotorSpeed(leftMotor, power);
}

// Drive function to make the robot snap 90d to the right
void turn90degreesRight()
{
	// snap right
	setMotorSpeed(leftMotor, 30);
	setMotorSpeed(rightMotor, -30);
	sleep(650);
}

// Drive function to make the robot snap 90d to the left
void turn90degreesLeft()
{
	// snap left
	setMotorSpeed(leftMotor, -30);
	setMotorSpeed(rightMotor, 30);
	sleep(650);
}

// Drive function to make the robot swing 90d to the right
void swingRight90D()
{
	// swing right
	setMotorSpeed(leftMotor, 50);
	setMotorSpeed(rightMotor, 30);
	sleep(1300);
}

// Drive function to make the robot swing 90d to the left
void swingLeft90D()
{
	// swing right
	setMotorSpeed(leftMotor, 30);
	setMotorSpeed(rightMotor, 50);
	sleep(1300);
}

// Drive function to move forward for one second
void forward1S()
{
	// go straight
	setMotorSpeed(leftMotor, 50);
	setMotorSpeed(rightMotor, 50);
	sleep(1250);
}

// Function to move around an obstacle
void avoidObstacle()
{
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	sleep(500);
	swingRight90D();
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	swingLeft90D();
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	forward1S();
	setMotorSpeed(rightMotor, 0);
	setMotorSpeed(leftMotor, 0);
	swingLeft90D();
}

// Function to generate a threshold of normal ground, and the line that must be followed
float generateThreshold()
{
	int n = 0;
	float threshold = 0;
	int countLight = 0;

	while(n < 2)
	{

		if(getButtonPress(buttonEnter) == 1) // Place the sensor on the line/ground and press
		{
			sleep(1000);
			displayCenteredBigTextLine(n*2,"Light = %d", SensorValue(S1));
			countLight = countLight+SensorValue(S1);
			n=n+1;
		}

	}

	threshold = countLight/n; // Send back the average
	displayCenteredTextLine(5, "Average = %f",threshold);
	sleep(2000);
	return threshold;

}


task main()
{
	bool noObstacle = true;
	float threshold = generateThreshold();

	
	while(true)
	{
		// 25
		if(SensorValue(S3) < 30)
		{
			avoidObstacle(); // Move around an obstacle
		}
		
		// Move left when the sensor value is higher than the threshold and there is no obstacle
		while(SensorValue(S1) > threshold & noObstacle)
		{
			driveLeft1(50);
		}
		
		// Move right when the sensor value is less than the threshold and there is no obstacle
		while(SensorValue(S1) < threshold & noObstacle)
		{
			driveRight1(50);
		}

	}

}
